#pragma kernel CopyTex
#pragma kernel Update
#pragma kernel UpdateVelocity

Texture2D<float4> inTex;
Texture2D<float4> velocityTex;

RWTexture2D<float4> noiseTex;
RWTexture2D<float4> outTex;

RWStructuredBuffer<float4> result;

SamplerState _LinearClamp;

[numthreads(8, 8, 1)]
void CopyTex(uint3 id : SV_DispatchThreadID)
{
    outTex[id.xy] = inTex[id.xy];
}

[numthreads(8,8,1)]
void Update(uint2 id : SV_DispatchThreadID)
{
    float w, h;
    inTex.GetDimensions(w, h);

    float2 offs = noiseTex[id].xy;
    float2 uv = float2(id.x / w, id.y / h);

    float4 ncol = inTex.SampleLevel(_LinearClamp, uv + offs, 0);
    float4 col = inTex.SampleLevel(_LinearClamp, uv, 0);

    outTex[id] = (col + ncol) * 0.5;
}

[numthreads(8,8,1)]
void UpdateVelocity(uint2 id : SV_DispatchThreadID)
{
    float4 ncol, vcol;

    // {
    //     float w, h;
    //     noiseTex.GetDimensions(w, h);

    //     float2 uv = float2(id.x / w, id.y / h);
    //     ncol = noiseTex.SampleLevel(_LinearClamp, uv, 0);
    // }

    // {
    //     float w, h;
    //     velocityTex.GetDimensions(w, h);

    //     float2 uv = float2(id.x / w, id.y / h);
    //     vcol = velocityTex.SampleLevel(_LinearClamp, uv, 0);
    // }

    ncol = noiseTex[id];
    vcol = velocityTex[id] * 0.1;

    noiseTex[id] = ncol + vcol;
}