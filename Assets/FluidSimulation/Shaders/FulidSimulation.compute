#pragma kernel UpdateAdvection
#pragma kernel UpdateDivergence
#pragma kernel UpdatePressure
#pragma kernel UpdateVelocity


Texture2D<float4> sourceVelocity;
Texture2D<float4> updateVelocity;
Texture2D<float4> sourcePressure;

RWTexture2D<float4> resultVelocity;
RWTexture2D<float4> resultPressure;
RWTexture2D<float4> resultDivergence;

SamplerState _LinearClamp;

float _DeltaTime;
float _Alpha;
float _Beta;
float _Scale;

//
// NOTE:-------------------------------------------------------
//
// 【圧力・発散の更新】
//
// Refer to : http://el-ement.com/blog/2015/03/16/gpu-fluid/
//
// 発散 ... (右の点の速度のx成分) – (左の点の速度のx成分) + (下の点の速度のy成分) – (上の点の速度のy成分)
// 圧力 ... (力のx成分) = {(左の点の圧力) – (右の点の圧力)} * 0.5
//          (力のy成分) = {(上の点の圧力) – (下の点の圧力)} * 0.5
// 速度 ... (速度のx成分) += {(左の点の圧力) – (右の点の圧力)} * 0.5
//          (速度のy成分) += {(上の点の圧力) – (下の点の圧力)} * 0.5
//
// ある点に隣り合う4点の圧力が決まっているとき、
// 中心の点の圧力をpにしたとすると、中心の点の発散は圧力の適用後
// 4 * p – (左の圧力) + (右の圧力) + (上の圧力) + (下の圧力)
// だけ変化します。
//
// 変化前の発散をdとすると、これが変化後に0になってほしいので、
// -d = (4 * p) – {(左の圧力) + (右の圧力) + (上の圧力) + (下の圧力)}
// 変形すると
// p = {(左の圧力) + (右の圧力) + (上の圧力) + (下の圧力) – d} * 0.25
// 
// これを解こうとすると、とある点の隣合う点の圧力があらかじめ求まっていないとならないため、
// 巨大な連立方程式を解く必要が出てしまう。
// 
// そこで、始めに圧力を0など適当な値にセットしておく
// セットされた圧力を使って新しい圧力を計算する
// 計算された圧力を使ってまた新しい圧力を計算する
// また計算された圧力を使ってさらに新しい圧力を計算する
//
// という風に、圧力を繰り返し計算しつつ徐々に精度を上げていく方法です。
// この方法は非常に強力で、Box2DやBulletなど各種物理エンジンでも使われています。

[numthreads(8,8,1)]
void UpdateAdvection(uint2 id : SV_DispatchThreadID)
{
    float w, h;
    sourceVelocity.GetDimensions(w, h);

    float2 uv = float2(id.x / w, id.y / h);

    float2 velocity = updateVelocity.SampleLevel(_LinearClamp, uv, 0).xy;
    float2 result = sourceVelocity.SampleLevel(_LinearClamp, uv - velocity * _DeltaTime, 0).xy;

    resultVelocity[id] = float4(result, 0.0, 0.0);
}

[numthreads(8,8,1)]
void UpdateDivergence(uint2 id : SV_DispatchThreadID)
{
    float w, h;
    sourceVelocity.GetDimensions(w, h);

    float2 uv = float2(id.x / w, id.y / h);
    float3 px = float3(1.0 / w, 1.0 / h, 0);

    float x0 = sourceVelocity.SampleLevel(_LinearClamp, uv - px.xz, 0).r;
    float x1 = sourceVelocity.SampleLevel(_LinearClamp, uv + px.xz, 0).r;
    float y0 = sourceVelocity.SampleLevel(_LinearClamp, uv - px.zy, 0).r;
    float y1 = sourceVelocity.SampleLevel(_LinearClamp, uv + px.zy, 0).r;

    float divergence = (x1 - x0 + y1 - y0) * 0.5;

    resultDivergence[id] = divergence.xxxx;
}

[numthreads(8,8,1)]
void UpdatePressure(uint2 id : SV_DispatchThreadID)
{
    float w, h;
    sourcePressure.GetDimensions(w, h);

    float2 uv = float2(id.x / w, id.y / h);
    float3 px = float3(1.0 / w, 1.0 / h, 0);

    float x0 = sourcePressure.SampleLevel(_LinearClamp, uv - px.xz, 0).r;
    float x1 = sourcePressure.SampleLevel(_LinearClamp, uv + px.xz, 0).r;
    float y0 = sourcePressure.SampleLevel(_LinearClamp, uv - px.zy, 0).r;
    float y1 = sourcePressure.SampleLevel(_LinearClamp, uv + px.zy, 0).r;

    float d = resultDivergence[id].r;
    float relaxed = (x0 + x1 + y0 + y1 + _Alpha * d) * _Beta;

    resultPressure[id] = relaxed.xxxx;
}

[numthreads(8,8,1)]
void UpdateVelocity(uint2 id : SV_DispatchThreadID)
{
    float w, h;
    sourcePressure.GetDimensions(w, h);

    float2 uv = float2(id.x / w, id.y / h);
    float3 px = float3(1.0 / w, 1.0 / h, 0);

    float x0 = sourcePressure.SampleLevel(_LinearClamp, uv - px.xz, 0).r;
    float x1 = sourcePressure.SampleLevel(_LinearClamp, uv + px.xz, 0).r;
    float y0 = sourcePressure.SampleLevel(_LinearClamp, uv - px.zy, 0).r;
    float y1 = sourcePressure.SampleLevel(_LinearClamp, uv + px.zy, 0).r;

    float2 v = sourceVelocity.SampleLevel(_LinearClamp, uv, 0).xy;
    float4 v2 = float4((v - (float2(x1, y1) - float2(x0, y0)) * 0.5) * _Scale, 1.0, 1.0);
    v2 *= 0.99;

    resultVelocity[id] = v2;
}
