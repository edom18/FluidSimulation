#pragma kernel Update
#pragma kernel UpdateVelocity
#pragma kernel UpdatePressure

Texture2D<float4> inTex;
Texture2D<float4> inNoiseTex;
Texture2D<float4> inVelocityTex;
Texture2D<float4> inPressureTex;

RWTexture2D<float4> outTex;
RWTexture2D<float4> outNoiseTex;
RWTexture2D<float4> outPressureTex;

SamplerState _LinearClamp;

[numthreads(8,8,1)]
void Update(uint2 id : SV_DispatchThreadID)
{
    float w, h;
    inTex.GetDimensions(w, h);

    float2 offs = inNoiseTex[id].xy;

    float2 uv = float2(id.x / w, id.y / h);

    float4 ncol = inTex.SampleLevel(_LinearClamp, uv + offs, 0);
    float4 col = inTex.SampleLevel(_LinearClamp, uv, 0);

    outTex[id] = (col + ncol) * 0.5;
}

// [numthreads(8,8,1)]
// void UpdateVelocity(uint2 id : SV_DispatchThreadID)
// {
//     float4 ncol, vcol;

//     {
//         float w, h;
//         inNoiseTex.GetDimensions(w, h);

//         float2 uv = float2(id.x / w, id.y / h);
//         ncol = inNoiseTex.SampleLevel(_LinearClamp, uv, 0);
//     }

//     {
//         float w, h;
//         inVelocityTex.GetDimensions(w, h);

//         float2 uv = float2(id.x / w, id.y / h);
//         vcol = inVelocityTex.SampleLevel(_LinearClamp, uv, 0);
//     }

//     outNoiseTex[id] = ncol + vcol;
// }

[numthreads(8,8,1)]
void UpdateVelocity(uint2 id : SV_DispatchThreadID)
{
    float4 ncol, vcol;

    {
        float w, h;
        inNoiseTex.GetDimensions(w, h);

        float2 uv = float2(id.x / w, id.y / h);
        ncol = inNoiseTex.SampleLevel(_LinearClamp, uv, 0);
    }

    {
        float w, h;
        inPressureTex.GetDimensions(w, h);

        float iw = 1.0 / w;
        float ih = 1.0 / h;

        float2 uv = float2(id.x / w, id.y / h);

        float up = inPressureTex.SampleLevel(_LinearClamp, uv + float2(0, -ih), 0).x;
        float down = inPressureTex.SampleLevel(_LinearClamp, uv + float2(0, ih), 0).x;
        float left = inPressureTex.SampleLevel(_LinearClamp, uv + float2(-iw, 0), 0).x;
        float right = inPressureTex.SampleLevel(_LinearClamp, uv + float2(iw, 0), 0).x;

        ncol.x += (left - right) * 0.5;
        ncol.y += (down - up) * 0.5;
    }

    outNoiseTex[id] = ncol;
}

//
// 【圧力・発散の更新】
//
// Refer to : http://el-ement.com/blog/2015/03/16/gpu-fluid/
//
// 発散 ... (右の点の速度のx成分) – (左の点の速度のx成分) + (下の点の速度のy成分) – (上の点の速度のy成分)
// 圧力 ... (力のx成分) = {(左の点の圧力) – (右の点の圧力)} * 0.5
//          (力のy成分) = {(上の点の圧力) – (下の点の圧力)} * 0.5
// 速度 ... (速度のx成分) += {(左の点の圧力) – (右の点の圧力)} * 0.5
//          (速度のy成分) += {(上の点の圧力) – (下の点の圧力)} * 0.5
//
// ある点に隣り合う4点の圧力が決まっているとき、
// 中心の点の圧力をpにしたとすると、中心の点の発散は圧力の適用後
// 4 * p – (左の圧力) + (右の圧力) + (上の圧力) + (下の圧力)
// だけ変化します。
//
// 変化前の発散をdとすると、これが変化後に0になってほしいので、
// -d = (4 * p) – {(左の圧力) + (右の圧力) + (上の圧力) + (下の圧力)}
// 変形すると
// p = {(左の圧力) + (右の圧力) + (上の圧力) + (下の圧力) – d} * 0.25
// 
// これを解こうとすると、とある点の隣合う点の圧力があらかじめ求まっていないとならないため、
// 巨大な連立方程式を解く必要が出てしまう。
// 
// そこで、始めに圧力を0など適当な値にセットしておく
// セットされた圧力を使って新しい圧力を計算する
// 計算された圧力を使ってまた新しい圧力を計算する
// また計算された圧力を使ってさらに新しい圧力を計算する
//
// という風に、圧力を繰り返し計算しつつ徐々に精度を上げていく方法です。
// この方法は非常に強力で、Box2DやBulletなど各種物理エンジンでも使われています。
//
[numthreads(8,8,1)]
void UpdatePressure(uint2 id : SV_DispatchThreadID)
{
    float w, h;
    inNoiseTex.GetDimensions(w, h);

    float iw = 1.0 / w;
    float ih = 1.0 / h;

    float2 uv = float2(id.x / w, id.y / h);

    uint3 io = uint3(1, 0, -1);

    float d, p;

    // Calucurate divergence.
    {
        // float2 up = inNoiseTex[id + io.yx].xy;
        // float2 down = inNoiseTex[id + io.yz].xy;
        // float2 left = inNoiseTex[id + io.zy].xy;
        // float2 right = inNoiseTex[id + io.xy].xy;
        float2 up = inNoiseTex.SampleLevel(_LinearClamp, uv + float2(0, ih), 0).xy;
        float2 down = inNoiseTex.SampleLevel(_LinearClamp, uv + float2(0, -ih), 0).xy;
        float2 left = inNoiseTex.SampleLevel(_LinearClamp, uv + float2(-iw, 0), 0).xy;
        float2 right = inNoiseTex.SampleLevel(_LinearClamp, uv + float2(iw, 0), 0).xy;

        d = (right.x - left.x) + (up.y - down.y);
    }

    {
        // float up = inPressureTex[id + io.yx].x;
        // float down = inPressureTex[id + io.yz].x;
        // float left = inPressureTex[id + io.zy].x;
        // float right = inPressureTex[id + io.xy].x;
        float up =  inPressureTex.SampleLevel(_LinearClamp, uv + float2(0, ih), 0).x;
        float down = inPressureTex.SampleLevel(_LinearClamp, uv + float2(0, -ih), 0).x;
        float left = inPressureTex.SampleLevel(_LinearClamp, uv + float2(-iw, 0), 0).x;
        float right = inPressureTex.SampleLevel(_LinearClamp, uv + float2(iw, 0), 0).x;

        p = (left + right + up + down - d) * 0.25;
    }

    outPressureTex[id] = p.xxxx;
}
